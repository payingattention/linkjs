# LinkJS

LinkJS provides event- and request-messaging between objects using HTTP as an underlying protocol. 

Features:

 - Abstraction over local and remote connections 
   - Local services use httpl:// (l for local)
   - All other protocols use ajax or node's request api
 - Events and requests using one API
   - If the connection is remote, events and implemented using the [server-sent events protocol](https://developer.mozilla.org/en-US/docs/Server-sent_events/Using_server-sent_events)
 - Simplified request/response API with a wrapper system based on Web Intents

## Basic Usage

First, during init:

```javascript
// add document-local servers
Link.register('localstorage.api', myLocalstorageServer);
Link.register('user-session.api', myUserSessionServer);
Link.register('navigation.ui', myNavUIServer);
//...
```

A consumer would then:

```javascript
// establish a session with the target
var localStorage = Link.session(this, 'httpl://localstorage.api', { events:true }); // events=true tells us to support events

// event listening
localStorage.on('localstorage-event', function(data) {
	//...
});

// requests
localStorage.request('post', { path:'/settings/myapp', 'content-type':'application/json', body:somedata })
	.then(function(response) {
		//...
	}, function(error) {
		//...
	});
```

The server:

```javascript
// create the server
var server = Link.server();

// event publishing
server.notify('localstorage-event', { foo:'bar' });
server.on('subscribe', function(client) {
	server.notify('another-localstorage-event', { foo:'bar' }, client);
});

// request handling
server.handle('post', { path:new RegExp('^/settings/(.*)/?$','i') }, function(request, match) {
	// ...
});
```

## Request/Response Wrappers

To save developers from having to build requests, a project can use wrappers (which are based on Web Intents). Possible actions are given URLs for reference (http://webintents.org/share, for example). Requests refer to those URLs and pass a parameter object which is converted into a request.

```javascript
localStorage.using('http://intent-registry.com/'); // probably called once during init
//...

// request according to an intent spec
localStorage.request('/collections/list', { col:'settings', filters:{ app:'myapp' }})
	.then(function(settings) {
		//...
	}, function(error) {
		//...
	});
```

This generates a `GET httpl://localstorage.api/settings?app=myapp` request. The request is generated by handler code which has been registered to the action (in the above case, `http://intent-registry.com/collections/list`). That handler code might look like this:

```javascript
Link.implement('http://intent-registry.com/', {
	'/collections/list':{
		toHTTP:function(obj) {
			return validate(function(v) {
				var request = {
					method:'get',
					path:'/'+v(obj.col, 'col', v.NotNull, v.IsString),
					accept:v(obj.accept||'application/json', 'accept', v.NotNull, v.IsString)
				};
				if (obj.filters) {
					request.query = v(obj.filters, 'filters', v.IsObject);
				}
				return request;
			});
		},
		fromHTTP:function(request) {
			return validate(function(v) {
				v(request.method, 'method', v.Equals('get'));
				var object = {
					col:v(request.path.substr(1), 'path', v.NotNull, v.IsString),
					accept:request.accept||'application/json'
				};
				if (request.query) {
					object.filters = request.query;
				}
				return object;
			});
		}
	}
});
```

A server may use the same system:

```javascript
// handler according to an intent spec
server.using('http://intent-registry.com/');
server.handle('/collections/list', { col:localStorage.hasCollection } function(params) {
	return localStorage.getCollection(params.col); //...
});
```

Why bother with the action URLs of intents? Three reasons.

 1. It leaves open the possibility of interoperating with Web Intents later.
 2. Link uses headers to communicate about the intents in use, so that it can speed up routing and provide information about its implementation.
 3. Action URLs can serve specs documenting how they should be implemented.