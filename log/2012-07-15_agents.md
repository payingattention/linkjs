Agents
======

2012/07/15 pfraze

Thinking over a model for multiple clients in a shared operating environment. Particularly wondering how state should be indicated and tracked within the browser when the independent software unit is a widget within the page rather than an entire page. Put another way, if you have two widgets running at once, what should the URL bar say?

Currently, linkshui designates a primary widget to relate to the URL bar and lets the others just live as untracked UIs. It then assigns resources to all widgets for manipulation and access. This may be a successful model, but the question is interesting enough to explore more.

Agents are clients which navigate resource links and accumulate state. It might make sense to split the page into multiple agents which load the widgets, thereby separating the concept of the client (an agent) from the widget that currently populates it.

```
+i                          - create new agent named "i"
i:get #inbox [html]         - load the "inbox" app (widget) into it
i:get #usr/email [json]     - load email data
```

By loading an application, the agent takes on a behavior for interpreting responses. It knows to use the email response to populate itself because the inbox defines that handling.

Each agent could also serve resources which indicate aspects of its state.

```
j:get #i/email [json] - pull out email data ("j" is another agent)
i:delete #i/email     - drop the email data from the inbox
i:delete #i/inbox     - drop the inbox behavior
-i                    - remove the agent
```

It's interesting to consider the different kinds of behaviors that could load into an agent. For instance, perhaps you could build NPCs in a game, composing together multiple behaviors.

```
char:get #npc [app]       - load the "npc" app
char:get #npc/roam [feat] - load the "roaming" feature
char:get #beer [item]     - add "beer" to inventory
```

This is a pretty massive abuse of the content-type system (the words in the brackets) and, really, REST as it's known and loved, but I'm okay with that. This is hypothetical anyway.

The interactions are fairly lengthy in this situation, but it might be possible to bundle request sequences into browser-shell scripts and use them to compose programs. For instance, a script to start your webmail might be:

```
+wm                           - new agent
wm:get #inbox [html]          - load inbox app
wm:get #contacts [js]         - load contacts-manager tool
wm:get #config/webmail [json] - load default sources
wm:get #usr/facebook/messages - add facebook manually
```

There would need to be an event system for handling responses. The default handler would load the response directly into the DOM. If that handler loads a widget, that widget could override the handling to decide how further responses are interpretted. That way, it opens itself to extension: running given callbacks, incorporating meaningful data, etc. 

---

2012/07/16 pfraze

This comes down to two practical issues: the URL's ability to represent (and thus restore) state, and the configuration of behavior.

On the first item, it could be possible to concatenate all of the widgets' URIs into a string which would then restore the active widgets. That might be nice for loading up a page configuration with a copy & paste, but it depends on just how much state can be and will need to be implied. If it can't be done well, it shouldn't be tried.

On the second issue, a simple choice is to let a config json kick things off, which is what linkshui currently does. What this log describes would allow more dynamic behavior; rather than an on-load set of values, it uses an imperative list of requests to build the environment. The advantage would be that behavior could load in/out during runtime. The questions are:

 - How successful would this system be? Would it work as expected?
 - How much power would a successful implementation of this system give? Would that power have a lot of practical use?
 - How much more complex would it be compared to onload config JSONs?

---

2012/07/16 pfraze

Test application, draft one

**login.req** (.req = requests file)

```
/* create session agent */
+sess
sess:get /login.html [text/html] /* loads the login tool */
/* after a successful auth, login.html loads the user's init.req and stores credentials in #sess/cred */
```

**init.req**

```
/* load the environment */
sess:get /main.html [text/html]

/* load apps */
sess:get #sess/loader /* enter loader state */
sess:get `[
    { "uri":"#tools/jeo", "module":"wjosdejong/jsoneditor" },
    { "uri":"#tools/prettify", "module":"google/prettify" }
]` [application/json] 
sess:get /webmail.json [application/json]

/* open webmail */
+wm
wm:get #apps/inbox [text/html] /* load inbox app */
wm:get #wm/load [text/html] /* enter load state */
wm:get #sess/creds [application/json] /* load user creds for services */
wm:get #srvc/myemail/cfg [application/json] /* load links needed for inbox to use email */
wm:get #srvc/twitter/cfg [application/json] /* load links needed for inbox to use twitter */
wm:get #wm/main [text/html] /* enter inbox main state */
```

**webmail.json**

```
[
    { "uri":"#apps/inbox", "module":"webmail/inbox" },
    { "uri":"#srvc/myemail", "module":"webmail/email", "host":"mywebmail.com" },
    { "uri":"#srvc/twitter", "module":"webmail/twitter" }
]
```

Quick note so I don't forget: look into the possibility that the agent URIs are just links. E.g. `#wm/load` actually points to `#apps/inbox/inst/0/load`.

---

2012/07/17 pfraze

Reactions to first draft:

No explicit distinction between a GET that loads a new application and a GET that loads a state within an application. Is that a problem?

This is a very stateful system. The example is easy because it includes the entire state history, from blank-slate to load. But what happens when `init.req` gets run a second time? What happens in a fail condition? 

At what point does the requests syntax introduce variables, control flow, and logic? Is that avoidable? If not, it would be nice to use javascript instead of inventing another incomplete language.

In fact...

**login.js** 

```js
// create session agent
var sess = Agent('sess');
sess.get('/login.html', 'text/html'); // loads the login tool
// after a successful auth, login.html loads the user's init.req and stores credentials in #sess/cred
```

**init.js**

```js
// load the environment
var sess = Agent('sess');
sess.get('/main.html', 'text/html');

// load apps
sess.get('#sess/loader'); // enter loader state
sess.get(Response('[
    { "uri":"#tools/jeo", "module":"wjosdejong/jsoneditor" },
    { "uri":"#tools/prettify", "module":"google/prettify" }
]','application/json'));
sess.get('/webmail.json', 'application/json');

// open webmail
var wm = Agent('wm');
wm.get('#apps/inbox', 'text/html'); // load inbox app
wm.get('#wm/load', 'text/html'); // enter load state
wm.get('#sess/creds', 'application/json'); // load user creds for services
wm.get('#srvc/myemail/cfg', 'application/json'); // load links needed for inbox to use email
wm.get('#srvc/twitter/cfg', 'application/json'); // load links needed for inbox to use twitter
wm.get('#wm/main', 'text/html'); // enter inbox main state
```

That does answer a lot of questions, even if it's a bit less pretty. One issue it brings out, however, is the question of async. Chaining could be used to indicate requests which don't need to block for each other, maybe after an async object is created:

```js
var wm = Agent('wm');
wm.get('#apps/inbox', 'text/html'); // load inbox app
wm.get('#wm/load', 'text/html'); // enter load state
wm.asnyc()
  .get('#sess/creds', 'application/json'); // load user creds for services
  .get('#srvc/myemail/cfg', 'application/json'); // load links needed for inbox to use email
  .get('#srvc/twitter/cfg', 'application/json'); // load links needed for inbox to use twitter
wm.get('#wm/main', 'text/html'); // enter inbox main state
```

I like how that reads, but I don't know how it could be done since requests are async by default. The agent could queue all of the requests, but that's problematic when you want to bring in logic or variable assignments based on responses.

Seems like the right direction, though. Will think on it.

---

2012/07/17 pfraze

And along we go.

There's no reason to expect or require long request sequences like this, and in fact it's a difficult model since it expects a high-level view of the environment (such as agent names). Some of the ideas aren't bad, though.

Rather than run in the global namespace making `Agent()` calls, apps should just set themselves up with this technique. The agent will be fed in as a parameter to the callback, and it will act as its interface to the servers and the dom.

```js
function(agent) {
    agent.post('#sess/loader', 'application/json', {
        modules: { ... } // same as webmail.json
    }).then(loadApp);

    var loadApp = function(r) {
        if (r.code == 200) {
            agent.get(agent.links.load).then(loadSources);
        } else {
            throw "Unable to load webmail servers: " + r.code + r.reason;
        }
    };

    var loadSources = function(r) {
        if (r.code == 200) {
            agent.when([
                agent.get('#sess/creds', 'application/json'),
                agent.get('#srvc/email/cfg', 'application/json')
                agent.get('#srvc/twitter/cfg', 'application/json')
            ]).then(function() {
                agent.get(agent.links.main);
            });
        } else {
            throw "Unable to load webmail sources: " + r.code + r.reason;
        }
    };
}
```

Simplifying in some ways, but have a lot to nail down about overall architecture now. Will stew, then change everything again.
